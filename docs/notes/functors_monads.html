<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="functors-applicatives-and-monads">Functors, Applicatives, and Monads</h1>
<p>In this section we discuss three important type classes that pertain to container types. They each express a key idea:</p>
<ul>
<li>Functors express the idea that we can <code>map</code> a function over a container type, by applying the function to its contents.</li>
<li>Applicatives express the idea of mapping a function over possibly multiple arguments.</li>
<li>Monads express the idea of sequencing effectful operations.</li>
</ul>
<h2 id="reading">Reading</h2>
<ul>
<li>Sections 12.1-12.3</li>
<li>Practice exercises (12.5): 1, 4, 7</li>
<li>Optional practice: 2, 3, 8</li>
<li><a href="https://wiki.haskell.org/State_Monad" class="uri">https://wiki.haskell.org/State_Monad</a></li>
</ul>
<h2 id="container-types-and-the-state-monad">Container Types and the State “Monad”</h2>
<p>Before we start exploring functors, let us consider three important container types that share certain features. All three types express the idea of “producing a value of a given type”, but they do so in different ways:</p>
<dl>
<dt><code>Maybe a</code></dt>
<dd>The Maybe type expresses the idea that the operation we performed may or may not have produced a value (i.e. it may have failed).
</dd>
<dt>[a]</dt>
<dd>The list type expresses the idea that the operation we performed may have returned more than one possible values (but all of the same type). A good example is the list comprehensions we discussed earlier in the course. A list is a convenient way to represent these possibly multiple results.
</dd>
<dt><code>IO a</code></dt>
<dd>The <code>IO</code> type expresses the idea that our operation interacts with the world in some way, and produces a value of type <code>a</code>.
</dd>
<dt><code>ST a</code></dt>
<dd>The State “monad” (we will discuss what that means later) is another example. It is meant to somehow maintain and update some “state”, and also return a value of type <code>a</code>. We will discuss this type now in some more detail.
</dd>
</dl>
<p>The idea of the State type is similar to our view of <code>IO</code> as a function that changed the “world” in some way and also produced a value of type <code>a</code>. The State type makes that more precise. It can work with very generic “states”, represented here with the type <code>s</code>. We can then make the following definition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">newtype</span> <span class="dt">ST</span> s a <span class="fu">=</span> <span class="dt">S</span> (s <span class="ot">-&gt;</span> (a, s))</code></pre></div>
<p>So a value of type <code>ST a</code> is a <em>transition</em> function that takes the current state, and produces a value of type <code>a</code> along with a new (updated) state. For technical reasons we place that function inside an <code>S</code> tag. We can easily write a function that removes the tag:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">runState ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> (a, s)
runState (<span class="dt">S</span> trans) x <span class="fu">=</span> trans x
<span class="co">-- Could also have done: runState (S trans) = trans</span></code></pre></div>
<p>We can also write a function that evaluates a given stateful computation for a state, discards the resulting state and simply returns the final value:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">evalState ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> s <span class="ot">-&gt;</span> a
evalState (<span class="dt">S</span> trans) st <span class="fu">=</span> x&#39;
    <span class="kw">where</span> (x&#39;, _) <span class="fu">=</span> runState (<span class="dt">S</span> trans) st
<span class="co">-- Alternative definition: evalState state = fst . runState state</span></code></pre></div>
<p>In order to meaningfully work with this new state structure though, we will need a couple of things:</p>
<ul>
<li>A way to set the state to a new value. This is akin to <code>putStr</code> printing something to the screen and hence changing the state of IO.</li>
<li>A way to read the state, while going through a stateful computation.</li>
<li>A way to turn a normal value into a stateful computation. We did this for <code>IO</code> with a function called <code>return</code>, and we will do the same here.</li>
<li>A way to apply a normal function to the value in the computation, while keeping the state the same.</li>
<li>A way to chain two computations together, so that the state transfers from the first to the second. In Haskell that operation has a name, <code>(&gt;&gt;=)</code>, typically called a “bind” operation.</li>
</ul>
<p>Let us take a look at each of these. Getting and setting the state is easy:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">get ::</span> <span class="dt">ST</span> s s
get <span class="fu">=</span> <span class="dt">S</span> (\st <span class="ot">-&gt;</span> (st, st))

<span class="ot">put ::</span> s <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
put st <span class="fu">=</span> <span class="dt">S</span> (\_ <span class="ot">-&gt;</span> ((), st))</code></pre></div>
<p>Now we need functions for returning a normal value as the result of a stateful computation that does not change the state, and also mapping the result values through a normal function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s a
return x <span class="fu">=</span> <span class="dt">S</span> (\st <span class="ot">-&gt;</span> (x, st))

fmap<span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> <span class="dt">ST</span> s b
fmap f (<span class="dt">S</span> trans) <span class="fu">=</span> <span class="dt">S</span> trans&#39;
    <span class="kw">where</span> trans&#39; st <span class="fu">=</span> (f x, st&#39;)
                      <span class="kw">where</span> (x, st&#39;) <span class="fu">=</span> trans st</code></pre></div>
<p>Now comes the tricky bit: We want to combine two stateful computations into a new stateful computation. Actually what we will do is slightly different: We will combine one stateful computation with a function that takes as input a result of the first computation, and uses it to produce a second stateful computation that is then carried out. It is probably the hardest part of the whole story:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> <span class="dt">ST</span> s a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">ST</span> s b) <span class="ot">-&gt;</span> <span class="dt">ST</span> s b
act1 <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> <span class="dt">S</span> trans
    <span class="kw">where</span> trans st <span class="fu">=</span> runState act2 st&#39;
                     <span class="kw">where</span> (x, st&#39;) <span class="fu">=</span> runState act1 st
                           act2     <span class="fu">=</span> f x</code></pre></div>
<p>This all looks a bit messy, but we only had to do it and understand it once! Now we can use this chaining instead of having to effectively manually do it every time. The even cooler thing is that this effectively allows us to use the IO-type notation with <code>do</code>, and Haskell will unravel that for us. For example, we can build a function that modifies the current state, as follows:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">modify ::</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> <span class="dt">ST</span> s ()
modify f <span class="fu">=</span> <span class="kw">do</span>
    st <span class="ot">&lt;-</span> get
    put st</code></pre></div>
<p>And Haskell turns that into:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">modify f <span class="fu">=</span> get <span class="fu">&gt;&gt;=</span> (\st <span class="ot">-&gt;</span> put (f st))
<span class="co">-- Can also write as:   get &gt;&gt;= (put . f)</span></code></pre></div>
<p>which is perhaps elegant but somewhat harder to read, especially if it involved more steps. In order for Haskell to be able to carry this out, it must know that our <code>ST</code> structure is a “monad”. We will discuss what that means later in the chapter, but effectively it just means having the “bind” operation we just defined.</p>
<p><strong>Practice</strong>:</p>
<ol style="list-style-type: decimal">
<li>Using “do” notation, write a function <code>incr :: ST Int ()</code> that increments the integer state by 1. Also do it by instead using <code>modify</code>.</li>
<li>Using “do” notation, write a function <code>account :: a -&gt; ST Int a</code> which “accounts” for the computation that produces a value of type <code>a</code>, by incrementing the integer state. Your function should simply increment the state and return the provided value.</li>
</ol>
<h2 id="functors">Functors</h2>
<p>TODO</p>
<h2 id="applicatives">Applicatives</h2>
<p>TODO</p>
<h2 id="monads">Monads</h2>
<p>TODO</p>
</body>
</html>
