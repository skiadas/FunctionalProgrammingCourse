<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-dark.css" rel="stylesheet" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>types_advanced</title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="advanced-haskell-typing-concepts">Advanced Haskell Typing concepts</h1>
<p>In this section we discuss some more advanced topics related to Haskell’s typing model.</p>
<p>We start with as discussion of the process of currying function parameters, which is possible because of the dominant nature of function values in functional programming. We then move on to discuss type variables which enable <em>generic programming</em> techniques. We end with a discussion of type classes and their significance.</p>
<h2 id="reading">Reading</h2>
<ul>
<li>Sections 3.7-3.9</li>
<li>Practice exercises (3.11): 1, 2, 3, 4, 5</li>
</ul>
<h2 id="curried-functions">Curried functions</h2>
<p>Looking at the example of the <code>range</code> function above:</p>
<pre class="haskell"><code>range :: (Int, Int) -&gt; [Int]
range (a, b) = [a..b]</code></pre>
<p>You may be tempted to think of this function as having as input <em>two parameters</em>, the <code>a</code> and the <code>b</code>. In reality it has only <em>one parameter</em>, namely the <em>tuple</em> <code>(a, b)</code>. This is why the type for the function has one thing on the left side of the arrow, namely the compound type <code>(Int, Int)</code>.</p>
<p>This is an important step: Compound types allow us the illusion of multiple parameters when in reality there is only one parameter.</p>
<p>There is however one other way of allowing multiple parameters, which is called <em>currying</em> in honor of Haskell Brooks Curry once again. The main idea is that functions can be specified to take <em>multiple parameters one at a time</em>. An example is in order, using the function <code>take</code> we saw earlier. A typical call to <code>take</code> would look like this:</p>
<pre class="haskell"><code>take 3 [1..10]</code></pre>
<p>So we are calling <code>take</code>, providing it with two parameters, and get back the result list.</p>
<p>However, the “curried” nature of the function lies in the fact that we could provide only the first argument, and thus create a new function that simply expects a list as input:</p>
<pre class="haskell"><code>prefix = take 3           -- prefix is now a function
prefix [1..10]            -- This is the same as `take 3 [1..10]`</code></pre>
<p>Providing only partial arguments to a curried function, and thus effectively creating a new function, is an extremely common practice, and the system is built so that this process is very efficient.</p>
<p>Let us look at another example:</p>
<pre class="haskell"><code>f x y = x + y                -- function of two variables
add3 = f 3                   -- new function
add3 10                      -- same as f 3 10</code></pre>
<h3 id="types-for-carried-functions">Types for carried functions</h3>
<p>A curried function is basically <em>a function whose return value is again a function</em>. When we write <code>f x y = x + y</code> what Haskell reads is:</p>
<blockquote>
<p><code>f</code> is a function of one argument <code>x</code>, whose result is a new function of one argument <code>y</code>, whose result is adding the <code>x</code> to the <code>y</code>.</p>
</blockquote>
<p>So Haskell reads <code>f x y</code> as:</p>
<pre class="haskell"><code>(f x) y</code></pre>
<p>In other words, <code>f</code> is applied to <code>x</code> and returns a function. That function is then applied to <code>y</code> to get us the result.</p>
<p>This helps us understand the type of such a function:</p>
<pre class="haskell"><code>f :: Int -&gt; (Int -&gt; Int)</code></pre>
<p>Since these functions are so common, it is customary to omit the parentheses: <em>Arrow types are right-associative</em>.</p>
<p><strong>Practice</strong>. Determine the types for the following functions. Do not worry about implementing the functions, you just need to determine their type.</p>
<ol type="1">
<li><code>take</code> from the standard functions. Assume the elements in the list are integers.</li>
<li><code>drop</code> from the standard functions. Assume the elements in the list are integers.</li>
<li><code>hasEnough</code> from the previous notes. Assume the elements in the list are integers.</li>
<li><code>isSubstring</code>: Given a string and another string, it returns whether the first string is contained somewhere within the second string.</li>
<li><code>max3</code>: Given three numbers, returns the maximum of the three.</li>
<li><code>evaluate</code>: This function is called with two (curried) arguments. The first argument is a function <code>f</code> that takes as input an integer, and returns as output an integer. The second argument is an integer. The result is what happens when we apply <code>f</code> to that second argument.</li>
</ol>
<h3 id="more-examples-of-curried-functions">More examples of curried functions</h3>
<p>We will discuss in this section some more examples of curried functions. We will study these functions and more later.</p>
<h4 id="zip">zip</h4>
<p><code>zip</code> is a function that takes two lists and groups them pairwise:</p>
<pre class="haskell"><code>zip [1,2,3] [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] = [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)]</code></pre>
<p>We can provide <code>zip</code> with only its first argument:</p>
<pre class="haskell"><code>enumerate = zip [1..]
-- Calling enumerate numbers the elements of the list we give it:
enumerate &quot;hey now!&quot;</code></pre>
<p>Let’s construct the type of the function <code>zip</code>. We start with its first argument: It expects a list as its first argument:</p>
<pre class="haskell"><code>zip :: [t] -&gt; ....</code></pre>
<p>What is returned if we provide just the first argument is now a function that expects the second argument, which is another list:</p>
<pre class="haskell"><code>zip :: [t] -&gt; ([s] -&gt; ...)</code></pre>
<p>Finally, the function returns tuples formed out of elements of the first list and the second list, so those tuples have type <code>(t, s)</code>. Therefore we end up with the following type for <code>zip</code>:</p>
<pre class="haskell"><code>zip :: [t] -&gt; ([s] -&gt; [(t, s)])
-- usually written as:
zip :: [t] -&gt; [s] -&gt; [(t, s)]</code></pre>
<h4 id="map">map</h4>
<p><code>map</code> is a function that takes as arguments a function and a list, and it applies the function to each element of the list and creates a new list in the process:</p>
<pre class="haskell"><code>times2 x = x * x
map times2 [2, 3, 4] -- results in [4, 9, 16]</code></pre>
<p>We can create a new function by providing just the function part to the <code>map</code> function:</p>
<pre class="haskell"><code>square = map times2
square [1, 2, 3, 4, 5] --  results in [1, 4, 9, 16, 25]
cube = map (\x -&gt; x * x * x)
-- toUpper is a function Char -&gt; Char
import Data.Char (toUpper)
-- This makes stringToUpper a function String -&gt; String
stringToUpper = map toUpper
stringToUpper &quot;hello there!&quot;  -- result is &quot;HELLO THERE!&quot;</code></pre>
<p>Let us now work out the type of <code>map</code>. It is a function that takes as input a function:</p>
<pre class="haskell"><code>map :: (... -&gt; ...) -&gt; (...)</code></pre>
<p>That first argument function must have some input and output types:</p>
<pre class="haskell"><code>map :: (a -&gt; b) -&gt; (...)</code></pre>
<p>Now <code>map</code> takes a second argument, which is in fact a list to whose elements we can apply the first argument function:</p>
<pre class="haskell"><code>map :: (a -&gt; b) -&gt; ([a] -&gt; ...)</code></pre>
<p>And finally it returns a list made out of the results of applying our function:</p>
<pre class="haskell"><code>map :: (a -&gt; b) -&gt; ([a] -&gt; [b])
-- usually written as:
map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code></pre>
<h2 id="polymorphism">Polymorphism</h2>
<p><strong>Polymorphism</strong> is a general term describing how the same piece of code might behave differently depending on the arguments provided. The term usually refers to a function or operator call. There are fundamentally two different kinds of polymorphism:</p>
<dl>
<dt><strong>Parametric Polymorphism</strong></dt>
<dd><p>refers to the situation where the same function code may act on values of different types but without changing the code. In that case the type of the corresponding value is a “parameter”. A good example of this is functions operating on lists: The function <code>head</code> does not particularly care what type of values your list contains, only that it contains a list. So it can operate on <em>any list type</em>, and the content type of the list type is in effect a parameter.</p>
<p>In C++ parametric polymorphism is achieved via <em>templates</em>, and in Java via <em>generics</em> (<code>&lt;T&gt;</code>).</p>
</dd>
<dt><strong>Ad-hoc Polymorphism</strong></dt>
<dd><p>refers to the situation where the same function symbol refers to multiple code chunks, and the decision on which code chunk to execute depends on the types of the arguments. A good example of this is the addition operation <code>+</code> or the equality operator <code>==</code>. Testing if two integers are equal requires a different code than testing if two strings are equal, yet they are both written the same way.</p>
<p>In C++ and Java you have probably encountered this as function/operator overloading, where the meaning of an expression like <code>a.add(b)</code> depends on the types of <code>a</code> and <code>b</code>, and different functions will be executed depending on those types. One can further say that object-oriented programming requires this kind of polymorphism in an essential way, to direct method calls to the correct place.</p>
</dd>
</dl>
<p>Almost every functional programming language implement parametric polymorphism in a similar way, via <em>type variables</em>. Support for ad-hoc polymorphism varies. Some languages don’t have it at all, and those that do implement it in different ways. Haskell uses a clever concept called <em>type classes</em> that we will discuss in a moment.</p>
<h3 id="parametric-polymorphism-type-variables">Parametric Polymorphism: Type Variables</h3>
<p>Some functions can do their job perfectly fine without needing to know precisely the type of value that they act on. A good example of that is the <code>tail</code> function for lists. A possible implementation for it could be simply:</p>
<pre class="haskell"><code>tail (x:xs) = xs</code></pre>
<p>If Haskell tries to determine the type of this function, it will run into some trouble. It can tell that the input must be a list, and that the output must be a list <em>of the same type</em>. But it has no way of knowing what type of elements the list contains, nor does it care; it can do its job regardless.</p>
<p>In order to assign a proper type to this function, we must expand our type system. We don’t want a <code>drop</code> function that only works on say <code>[Int]</code> values, nor one that only works on <code>[Char]</code> values. We need a function that only works on any <code>[...]</code> values.</p>
<p>This is where <em>type variables</em> come in. A <strong>type variable</strong> is essentially a variable used to represent a type in a function signature. These are lowercase and typically consist of only one letter, like <code>a</code>, <code>b</code>, <code>t</code>. When a function is being called, these types are <strong>instantiated</strong> for a particular type.</p>
<p>As an example, the type of the <code>drop</code> function would therefore be:</p>
<pre class="haskell"><code>drop :: Int -&gt; [t] -&gt; [t]</code></pre>
<p>This says that drop accepts as input a value of any list type, and returns a value of <em>the same list type</em>. When the function is actually used, like in</p>
<pre class="haskell"><code>drop 1 [1, 2, 3]    -- t=Int.  Used as  drop :: Int -&gt; [Int] -&gt; [Int]
drop 1 &quot;abc&quot;        -- t=Char. Used as  drop :: Int -&gt; [Char] -&gt; [Char]</code></pre>
<p>a specific type is chosen in place of the variable, for each use of the function. But the body of the function that is executed does not change.</p>
<p>If the body of the function does not provide any constraints on the types of some of the parameters, the function typically ends up with a parametric type (unless the programmer specified a more stringent type).</p>
<p>We can also have <em>multiple type variables</em>, if there are elements in the function that have arbitrary but different types. An example is the <code>zip</code> function. It takes two lists of elements and returns a new list by forming pairs from elements one from each list. It looks roughly like this:</p>
<pre class="haskell"><code>zip (x:xs) (y:ys) = (x, y) : zip xs ys</code></pre>
<p>In this case we don’t care what the types of the two lists are, and they can be different from each other. But the type of the result list depends on them. We could write the type for <code>zip</code> thus:</p>
<pre class="haskell"><code>zip :: [a] -&gt; [b] -&gt; [(a, b)]</code></pre>
<p><strong>Practice</strong>: Determine the types of the following functions:</p>
<ol type="1">
<li><code>head</code>, <code>tail</code>.</li>
<li><code>take</code>.</li>
<li><code>length</code>.</li>
<li><code>fst</code>. This function takes as input a tuple of two elements and returns the first element.</li>
</ol>
<h3 id="ad-hoc-polymorphism-overloaded-types-and-type-classes">Ad-hoc Polymorphism: Overloaded Types and Type Classes</h3>
<p>Ad-hoc polymorphism is a bit trickier, especially in a language that performs type inference, as the system must be able to see an expression like <code>x+y</code> and infer some type information regarding <code>x</code> and <code>y</code>. This is accomplished by a couple of related ideas, namely <em>overloaded types</em> (often refered to as <em>bounded polymorphism</em>) and <em>type classes</em>.</p>
<p>A <strong>overloaded type</strong> is a type that comes with a certain constraint. For instance the type of an <code>add</code> function may look like this:</p>
<pre class="haskell"><code>add :: Num t =&gt; t -&gt; t -&gt; t
add x y = x + y</code></pre>
<p>What this tells us that is that the function add takes two arguments of a certain type and returns a value of that same type, but it can’t just be any type. It has the constraint <code>Num t</code>, which says that it must be a “number type”.</p>
<p>Even the type of a single number by itself has a similar constraint, because that number can be thought of as one of the many number types:</p>
<pre class="haskell"><code>3 :: Num t =&gt; t</code></pre>
<p>These constraints come from the so-called type-classes: A <strong>type class</strong> is a list of specifications for operations on a type. An <strong>instance</strong> of a type class is a specific type along with definitions for these operations.</p>
<p>A good example of a type-class is the <code>Num</code> type class for numbers. Any instance of this class must provide implementations for the following functions:</p>
<pre class="haskell"><code>-- The Num class. An instance Num a must implement:
(+) :: a -&gt; a -&gt; a
(-) :: a -&gt; a -&gt; a
(*) :: a -&gt; a -&gt; a
negate :: a -&gt; a
abs :: a -&gt; a
signum :: a -&gt; a         -- sign</code></pre>
<p>If we wanted to, we could for instance make the <code>Char</code> type an instance of the Num class by specifying how each of these operations would work. From that point on we could be writing <code>'a' + 'b'</code> and the system won’t complain.</p>
<h4 id="standard-type-classes">Standard Type Classes</h4>
<p>Implementing your own type class is a more advanced feature. But there are many standard type classes that are in constant use, and we will see more as we move on. Here are some of the standard ones:</p>
<dl>
<dt>Num</dt>
<dd><p>We already encountered this earlier. It contains the following functions:</p>
<pre class="haskell"><code>(+) :: a -&gt; a -&gt; a
(-) :: a -&gt; a -&gt; a
(*) :: a -&gt; a -&gt; a
negate :: a -&gt; a
abs :: a -&gt; a
signum :: a -&gt; a</code></pre>
</dd>
<dt>Eq</dt>
<dd><p>The “equality” type class. Values of types that implement Eq can be compared to each other. This contains the following functions:</p>
<pre class="haskell"><code>(==) :: a -&gt; a -&gt; Bool
(/=) :: a -&gt; a -&gt; Bool</code></pre>
<p>You can see a “type error” if you try to compare two functions, as function types are not instances of the <code>Eq</code> class:</p>
<pre class="haskell"><code>(+) == (-)    --- Look at the error</code></pre>
</dd>
<dt>Ord</dt>
<dd><p>This represents ordered types. These are an extension of <code>Eq</code>, and in addition to those functions must also implement these:</p>
<pre class="haskell"><code>(&lt;) :: a -&gt; a -&gt; Bool
(&lt;=) :: a -&gt; a -&gt; Bool
(&gt;) :: a -&gt; a -&gt; Bool
(&gt;=) :: a -&gt; a -&gt; Bool
min :: a -&gt; a -&gt; Bool
max :: a -&gt; a -&gt; Bool</code></pre>
</dd>
<dt>Show</dt>
<dd><p>This represents types whose value have a string representation. These are the only values that Haskell will print out for you without complaining. They need to implement a single function:</p>
<pre class="haskell"><code>show :: a -&gt; String</code></pre>
</dd>
<dt>Read</dt>
<dd><p>This represents types that know how to turn a string into a value. They need to implement a single method:</p>
<pre class="haskell"><code>read :: String -&gt; a</code></pre>
<p>Here’s an example use of this, to read in a tuple from a string representation:</p>
<pre class="haskell"><code>read &quot;(True, 5)&quot; :: (Bool, Int)   -- We must specify the return type.</code></pre>
<p>Integral</p>
</dd>
<dd><p>This is an extension of the <code>Num</code> class. It further requires the implementation of integer division operations:</p>
<pre class="haskell"><code>div :: a -&gt; a -&gt; a
mod :: a -&gt; a -&gt; a</code></pre>
</dd>
<dt>Fractional</dt>
<dd><p>This is an extension of the <code>Num</code> class that supports fractional division and reciprocation:</p>
<pre class="haskell"><code>(/) :: a -&gt; a -&gt; a
recip :: a -&gt; a</code></pre>
</dd>
</dl>
<p>Many of these type classes extend to compound types if there is a specification on how to do so. For example tuples are instances of the class <code>Ord</code> as long as their components are, and the same for lists:</p>
<pre class="haskell"><code>(3, 4) &gt; (2, 5)
[3, 4, 5] &gt; [2, 5, 6, 7]</code></pre>
<p><strong>Practice</strong>: Figure out the types of the following functions, including type class specifications:</p>
<ol type="1">
<li><p><code>posDiff</code> defined by <code>posDiff x y = if x &gt; y then x - y else y - x</code>.</p></li>
<li><p><code>maxList</code> defined on lists by:</p>
<pre class="haskell"><code>maxList (x:[]) = x
maxList (x:xs) = if x &gt; restMax then x else restMax
            where restMax = maxList xs</code></pre></li>
<li><p><code>has</code> that checks for the existence of an element in a list, and is defined by:</p>
<pre class="haskell"><code>has elem []       = False
has elem (x:rest) = elem == x || has elem rest</code></pre></li>
</ol>
<script type="text/javascript">
let els = document.getElementsByTagName("pre");
for (const el of els) {
  const lang = el.getAttribute("class");
  if (lang != "") {
      el.children[0].setAttribute("class", "language-"+lang);
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.js"></script>
</body>
</html>
