<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism-dark.css" rel="stylesheet" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>types_custom</title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="custom-types-and-the-option-type">Custom Types and the Option Type</h1>
<p>In this section we discuss one of the most important features of Haskell and many functional programming languages, namely the ability to create new types. In this section we explore simple cases of new types. Later on we will look at the quite powerful recursive types, that allow us to define recursive structures.</p>
<h2 id="reading">Reading</h2>
<ul>
<li>Sections 8.1-8.3</li>
</ul>
<h2 id="type-aliases-and-custom-types">Type Aliases and Custom Types</h2>
<p>One of the most important features of Haskell is the ability to create new types from existing types. They are an important way of organizing our programs, by defining the kinds of values that our programs would operate on.</p>
<p>There are fundamentally two ways of producing new types: <strong>type aliases</strong> and <strong>custom data types</strong>.</p>
<h3 id="type-aliases">Type Aliases</h3>
<p>Type aliases are simply new names we give to existing types. For example, we can define 2-dimensional and 3-dimensional point types as aliases of tuple types:</p>
<pre class="haskell"><code>type Point2D = (Double, Double)
type Point3D = (Double, Double, Double)</code></pre>
<p>We can then use <code>Point2D</code> and <code>Point3D</code> in any place where we would use the corresponding tuple types. The two are indistinguishable, hence the use of the word <em>alias</em>.</p>
<p>Type aliases may also contain parametric types. For instance, we can create an “associative list”, which is a list containing key-value pairs, like so:</p>
<pre class="haskell"><code>type Assoc k v = [(k, v)]</code></pre>
<p>Here <code>k</code> and <code>v</code> are parametric types.</p>
<h3 id="custom-data-types">Custom Data Types</h3>
<p>Custom data types are what is often refered to as a “union type”. In a custom data type we state that a value of this type can be any of a number of alternatives, all differentiated by a keyword called a “constructor”. The simplest example of a union type is in fact the <code>Bool</code> type, which we can define as follows:</p>
<pre class="haskell"><code>data Bool = False | True</code></pre>
<p>So a custom data type starts with the keyword <code>data</code> instead of <code>type</code>, and it is followed by the type name, in this case <code>Bool</code>. After the equals sign we offer the various alternative forms that a value of this type can take, separated by vertical lines. In this example, there are exactly two possibilities, <code>True</code> and <code>False</code>.</p>
<p>As another example, in a card game we could specify a type representing the card’s suit:</p>
<pre class="haskell"><code>data Suit = Clubs | Diamonds | Hearts | Spades</code></pre>
<p>We could then define a card as:</p>
<pre class="haskell"><code>type Card = (Int, Suit)</code></pre>
<p>And create cards like <code>(5, Diamonds)</code>.</p>
<h4 id="deriving-type-classes-for-data-types">Deriving type classes for data types</h4>
<p>Haskell can automatically generate standard implementations for many data types, if we ask it to. We do this by adding the keyword <code>deriving</code> at the end of the definition, like so:</p>
<pre class="haskell"><code>data Bool = False | True    deriving (Eq, Ord, Show)</code></pre>
<p>It does so in a straightforward way: Two values are equal only if they are exactly the same, the values are ordered from left to right in their definition (so <code>True &gt; False</code>) and they turn to their corresponding strings under the <code>show</code> function.</p>
<h4 id="data-types-as-union-types">Data types as union types</h4>
<p>What we have seen above is the use of data types to define what is typically known as <strong>enumerations</strong>. It is effectively a sequence of possible values, that we could have represented by distinct numbers but which are more meaningful with these words. In C one would typically use constants for a similar purpose, but without the benefits of automatic type-checking: if <code>True</code> was simply another way of saying <code>1</code>, then if a program ended up saying <code>if 1 then ... else ...</code> then we wouldn’t know if that is because we really wanted 1 there to represent truthiness or if we made a mistake.</p>
<blockquote>
<p>Enumerations force type-checking and can prevent many hard-to-detect errors.</p>
</blockquote>
<p>We will now discuss another important use of data types, with similar motivations. This is the full use of data types to represent <strong>union types</strong>. As an example, suppose that we wanted to write a program that can work with temperatures. We want the system to be able to work with both Fahrenheit and Celsius temperatures at the same time. One way to do this, with some problems that we will discuss in a moment, is to use a tuple type like so:</p>
<pre class="haskell"><code>data TempScale = F | C          deriving (Eq, Show)
type Temp = (TempScale, Double)</code></pre>
<p>So then we could have temperatures like <code>(F, 56)</code> for “56 Fahrenheit” and so on. We could then write a function:</p>
<pre class="haskell"><code>toFahrenheit :: Temp -&gt; Double
toFahrenheit (F, fTemp) = fTemp
toFahrenheit (C, cTemp) = 9 / 5 * cTemp + 32</code></pre>
<p>This can work, but it has a number of subtle problems. The main problem is that there is no way to guarantee that a function would account for both temperatures. Someone could write a <code>toFahrenheit</code> function like so:</p>
<pre class="haskell"><code>toFahrenheit (_, temp) = temp</code></pre>
<p>which is of course logically wrong, but the type system does not prevent one from doing so.</p>
<p>Data types offer us a different approach that forces us to handle the different temperatures. Instead of representing a temperature as a tuple, we represent it as a double with a “tag” in front of it to distinguish between F or C. It would look like this:</p>
<pre class="haskell"><code>data Temp = F Double | C Double   deriving (Show)</code></pre>
<p>Then we can write a temperature value as <code>F 23</code> or as <code>C 12.3</code> and so on. The scale tag is now part of the double value, and you cannot look at that value without discussing the tag. To take the value out we need to do a pattern-match, and we are forced to have both F and C branches:</p>
<pre class="haskell"><code>toFahrenheit :: Temp -&gt; Double
toFahrenheit (F fTemp) = fTemp
toFahrenheit (C cTemp) = 9 / 5 * cTemp + 32</code></pre>
<p>We have just seen a new form of pattern-matching. Using a data-type’s constructor (here F and C) along with a pattern for their contents.</p>
<p>As another example, suppose we wanted to do some arithmetic with fractions. We want to allow two kinds of numbers: integers and fractions. We want the two kinds of numbers to coexist in one type. We can represent fractions as integer pairs: <code>(Int, Int)</code>. The question is how to handle the intgers. One option would be to force each integer <code>n</code> into the fraction <code>n / 1</code>. But a more expressive option is to use a union type:</p>
<pre class="haskell"><code>data Number = NumInt Int | NumFrac (Int, Int)</code></pre>
<p>Then we could write a multiply function, that looks like this (without worrying about simplifying the fraction):</p>
<pre class="haskell"><code>mult :: Number -&gt; Number -&gt; Number
NumInt n `mult` NumInt m                 = NumInt (n * m)
NumInt n `mult` NumFrac (top, bottom)    = NumFrac (n * top, bottom)
NumFrac (top, bottom) `mult` NumInt n    = NumFrac (n * top, bottom)
NumFrac (t1, b1) `mult` NumFrac (t2, b2) = NumFrac (t1 * t2, b1 * b2)</code></pre>
<h3 id="the-maybe-option-type">The Maybe option type</h3>
<p>One particular built-in datatype deserves special mention. It is known as the <code>Maybe</code> type in Haskell, and also as the Option type in other languages. Its premise is simple: It allows you to carry one value around, but also allows the possibility of no value at all. For example, imagine we write a <code>lookup</code> method that looks for an key in an associative list:</p>
<pre class="haskell"><code>lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; b</code></pre>
<p>This function is meant to search for the <code>a</code> part of the pair in the list, and if it finds it then it returns the corresponding <code>b</code> part. But what should happen if a suitable <code>a</code> part is not found? What value would the function return?</p>
<p>In other languages we have something like a <code>null</code> value. This is highly problematic, for a reason similar to the one described in temperatures.</p>
<blockquote>
<p>Using the <code>null</code> value to indicate failure, we have no way of expressing in our type system whether a function may return <code>null</code> for its result, and whether a function should be handling <code>null</code> as a possible input to one of its arguments. These functions all look alike as far as their signature is concerned.</p>
</blockquote>
<p>So for example <code>lookup</code> has no way of telling its users “hey my answer may be null so you better handle that possibility”. Similarly the typechecker has no way of knowing if a function that uses the result of lookup bothers to check for the null case.</p>
<p>Option types solve these problems for us. The <code>Maybe</code> type is defined as follows:</p>
<pre class="haskell"><code>data Maybe a = Nothing | Just a</code></pre>
<p>So a value of type <code>Maybe Int</code> is either <code>Nothing</code> or something like <code>Just 5</code>. Then the (proper) type for the <code>lookup</code> function above is (for completeness we include its implementation):</p>
<pre class="haskell"><code>lookup :: Eq a =&gt; a -&gt; [(a, b)] -&gt; Maybe b
lookup key []                = Nothing
lookup key ((target, value) : rest)
    | key == target          = Just value
    | otherwise              = lookup key rest</code></pre>
<p>Now anyone who wants to use the result of the lookup must do a pattern match on the two different forms, and as a result somehow handle the <code>Nothing</code> case.</p>
<pre class="haskell"><code>reportLookupResult :: (Eq a, Show b) =&gt; a -&gt; [(a, b)] -&gt; String
reportLookupResult key lst = handleResult (lookup key lst)
    where handleResult Nothing = &quot;No matches found!&quot;
          handleResult (Just someb) = &quot;Found one: &quot; ++ show someb</code></pre>
<p>A standard example of this is a “safe division” function, which does not allow you to divide by 0. It would look like this:</p>
<pre class="haskell"><code>safeDivide :: Num t =&gt; t -&gt; t -&gt; Maybe t
safeDivide _ 0  = Nothing
safeDivide n m  = Just (n / m)</code></pre>
<h4 id="standard-functions-for-maybe">Standard functions for Maybe</h4>
<p>There are a number of standard functions for the Maybe type. We declare them here, and ask you to implement them for practice:</p>
<pre class="haskell"><code>-- Empty or one-element list
toList :: Maybe a -&gt; [a]
-- Apply the function to the a if there is one, otherwise just pass the default b
maybe :: b -&gt; (a -&gt; b) -&gt; Maybe a -&gt; b
-- Preserve the Nothing or apply the function
fmap :: (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
-- Preserve the Nothing or apply the function
(&gt;&gt;=) :: Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b
-- Preserve the Nothing or keep the b value
(&gt;&gt;) :: Maybe a -&gt; Maybe b -&gt; Maybe b
-- Wrap a value in Maybe
return :: a -&gt; Maybe a
-- Preserve the Nothing or apply the function
(&lt;*&gt;) :: Maybe (a -&gt; b) -&gt; Maybe a -&gt; Maybe b
-- Apply the function if possible
foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; Maybe a -&gt; b</code></pre>
<p><strong>Practice</strong>: Implement the above functions.</p>
<script type="text/javascript">
let els = document.getElementsByTagName("pre");
for (const el of els) {
  const lang = el.getAttribute("class");
  if (lang != "") {
      el.children[0].setAttribute("class", "language-"+lang);
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.js"></script>
</body>
</html>
