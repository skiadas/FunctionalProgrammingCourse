<!DOCTYPE html>
<html>
<head>
  <link href='https://fonts.googleapis.com/css?family=Roboto:400,700' rel='stylesheet' type='text/css'>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/themes/prism.css" rel="stylesheet" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>state_monad</title>
  <style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet" href="https://skiadas.github.io/css/course.css" type="text/css" />
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
</head>
<body>
<h1 id="expressing-state-in-haskell">Expressing State in Haskell</h1>
<p>A challenge for those new to Haskell and its lack of mutation is how Haskell handle state. In this section we discuss how this can be accomplished. The main idea is “weave your state through the computation”.</p>
<h2 id="a-state-example-statement-interpretation">A State Example: Statement Interpretation</h2>
<p>As an illustration of this idea, let us imagine a small programming language. It has expressions that perform basic arithmetic (addition and multiplication), but also allows us to store values in variables as well as to print values. This is done via statements. Here is a listing of the basic types.</p>
<pre class="haskell"><code>type Symbol = String  -- alias for strings when used as language symbols/variables.
data Expr = Numb Double     -- number literal
          | Var Symbol      -- variable lookup
          | Add Expr Expr   -- expression for addition
          | Prod Expr Expr  -- expression for multiplication
data Stmt = Assign Symbol Expr  -- variable assignment
          | Seq Stmt Stmt       -- statement followed by another statement
          | Print Expr          -- print the result of an expression evaluation
          | PrintMem            -- print all stored values</code></pre>
<p>A program is simply a <code>Stmt</code> value, which can in turn be a sequence of <code>Stmt</code>s using the <code>Seq</code> constructor. For example here is one such program:</p>
<pre class="haskell"><code>Seq (Assign &quot;x&quot; (Add (Numb 2) (Numb 4))) $   -- x &lt;- 2 + 4
Seq (Print $ Var &quot;x&quot;) $                      -- print x
PrintMem                                     -- print all memory</code></pre>
<p>In order to execute such a program, we need to maintain a “memory” of stored values for the variables:</p>
<pre class="haskell"><code>type Value = Double     -- Doubles are the only possible values in this language
type Memory = [(Symbol, Value)]

store  :: Symbol -&gt; Value -&gt; Memory -&gt; Memory
store s v []             = [(s, v)]
store s v ((s&#39;,v&#39;):rest) = case compare s s&#39; of
   LT -&gt; (s, v):(s&#39;, v&#39;):rest
   EQ -&gt; (s, v):rest
   GT -&gt; (s&#39;, v&#39;):store s v rest

lookup :: Symbol -&gt; Memory -&gt; Maybe Value
lookup s []              = Nothing
lookup s ((s&#39;, v&#39;):rest) = case compare s s&#39; of
   LT -&gt; Nothing
   EQ -&gt; Just v&#39;
   GT -&gt; lookup s rest</code></pre>
<p>Now we need to write the main functions, one to evaluate expressions and one to evaluate statements. The challenge is this: In order for them to do their work, these functions must have the current state of the Memory available to them, and in the case of the statement must also be able to <em>change</em> the value of Memory by returning an updated Memory. Therefore the “types” of these functions might be as follows:</p>
<pre class="haskell"><code>evalExpr :: Expr -&gt; Memory -&gt; Value
evalStmt :: Stmt -&gt; Memory -&gt; (IO (), Memory)</code></pre>
<p>Note the distinction: expressions return values, while statements interact with the user (e.g. print something).</p>
<p>Let’s consider how <code>evalExpr</code> may be implemented. It should be a simple set of cases for each type of expression:</p>
<pre class="haskell"><code>evalExpr :: Expr -&gt; Memory -&gt; Value
evalExpr (Numb x) _ = x
evalExpr (Var s) mem =
    case lookup s mem of
        Nothing -&gt; error (&quot;Cannot find symbol: &quot; ++ s)
        Just v  -&gt; v
evalExpr (Add e1 e2) mem = v1 + v2
    where v1 = evalExpr e1 mem
          v2 = evalExpr e2 mem
evalExpr (Prod e1 e2) = v1 * v2
    where v1 = evalExpr e1 mem
          v2 = evalExpr e2 mem</code></pre>
<p>Next we would have <code>evalStmt</code>, which is trickier as it often has to <em>update</em> the memory. It must therefore return the updated memory:</p>
<pre class="haskell"><code>evalStmt :: Stmt  -&gt; Memory -&gt; (IO (), Memory)
evalStmt (Assign symbol expr) mem =  (return (), mem&#39;)
    where v    = evalExpr expr mem   -- Evaluate the expression
          mem&#39; = store symbol v mem  -- Update the memory with the new value
                                     -- Return the updated memory!
evalStmt (Seq stmt1 stmt2) mem = (io&#39; &gt;&gt; io&#39;&#39;, mem&#39;&#39;)
    where (io&#39;, mem&#39;)   = evalStmt stmt1 mem
          (io&#39;&#39;, mem&#39;&#39;) = evalStmt stmt2 mem&#39;   -- Use updated memory
evalStmt (Print expr) mem = (putStrLn $ show v, mem)
    where v = evalExpr expr mem
evalStmt PrintMem mem = (printMemory mem, mem)

printMemory :: Memory -&gt; IO ()
printMemory []            = return ()
printMemory ((s, v):rest) = do
    putStrLn $ s ++ &quot; = &quot; ++ show v
    printMemory rest

evaluate :: Stmt -&gt; IO ()
evaluate stmt = io
    where (io, _) = evalStmt stmt []</code></pre>
<p>This all works reasonably well. But note for example the kind of work that <code>evalStmt</code> had to do to handle a <code>Seq</code> case: It has to update the memory with the result of the first statement, then make sure to execute the second statement with the updated memory. We often describe that as “weaving in the memory through the steps”.</p>
<p>It would be good if we had a better way to express this. This is where the <em>State Monad</em> comes in.</p>
<h2 id="the-state-monad">The State Monad</h2>
<p>Effectively the state monad is this, if we were allowed to write it:</p>
<pre class="haskell"><code>data State a = mem -&gt; (a, mem)</code></pre>
<p>So a “state” is a function that takes a memory and returns a pair of the memory as well as some kind of value of a certain parametric type. In fact, since <code>mem</code> is just what the “state” is in our case, we should probably parametrize the “state” by another parametric type, <code>s</code>:</p>
<pre class="haskell"><code>data State s a = s -&gt; (a, s)</code></pre>
<p>This is the essence of the state monad. However, this is not valid, so we need more something like this:</p>
<pre class="haskell"><code>data State s a = ST (s -&gt; (a, s))</code></pre>
<p>As we won’t need this in that generality, let’s stick to the original version with <code>Memory</code> as the state that is maintained. We will call a value of this type a <code>ProgStateT</code> for “program state transformer”:</p>
<pre class="haskell"><code>data ProgStateT a = PST (Memory -&gt; (a, Memory))</code></pre>
<p>So a <code>ProgStateT</code> value is a transformation that takes a memory, possibly transforms it in some way, and also produces a value of type <code>a</code>.</p>
<p>With that in mind, our <code>evalStmt</code> function will gain the signature:</p>
<pre class="haskell"><code>evalStmt :: Stmt -&gt; ProgStateT (IO ())</code></pre>
<p>And our <code>evaluate</code> becomes:</p>
<pre class="haskell"><code>evaluate :: Stmt -&gt; IO ()
evaluate stmt = getResult (evalStmt stmt) []

getResult :: ProgStateT a -&gt; Memory -&gt; a
getResult (PST f) mem = fst $ f mem</code></pre>
<p>Now we would like to look at the parts of <code>evalStmt</code>. Here is a direct translation of the previous version:</p>
<pre class="haskell"><code>evalStmt :: Stmt -&gt; ProgStateT (IO ())
evalStmt (Assign symbol expr) =
    PST (\mem -&gt; let v    = evalExpr expr mem
                     mem&#39; = store symbol v mem
                 in (return (), mem&#39;))
evalStmt (Seq stmt1 stmt2) =
  PST (\mem -&gt; let PST pst1      = evalStmt stmt1
                   PST pst2      = evalStmt stmt2
                   (io&#39;, mem&#39;)   = pst1 mem
                   (io&#39;&#39;, mem&#39;&#39;) = pst2 mem&#39;
               in (io&#39; &gt;&gt; io&#39;&#39;, mem&#39;&#39;))
evalStmt PrintMem =
  PST (\mem -&gt; (printMemory mem, mem))
evalStmt (Print expr) =
  PST (\mem -&gt; let v = evalExpr expr mem
               in (putStrLn $ show v, mem))</code></pre>
<p>We moved the <code>mem</code> parameter to the other side, creating a lambda expression, then wrapped this in <code>PST</code>. Having to wrap and unwrap the PSTs is a bit awkward, but we’ll be able to write things nicer later on.</p>
<p>Let’s take a look at the <code>PrintMem</code> clause: It effectively simply applies a function to the memory, then returns the resulting value along with the unaltered memory. We can write functions that perform these two steps separately: One function turns our memory into a value, done as a Program State Transformer:</p>
<pre class="haskell"><code>getMemory :: ProgStateT Memory
getMemory = PST (\mem -&gt; (mem, mem))</code></pre>
<p>The other function takes any kind of function <code>a-&gt;b</code> and turns it into a function <code>ProgStateT a -&gt; ProgStateT b</code>, by applying the function to the value without affecting the memory. This function is appropriately called <code>fmap</code>:</p>
<pre class="haskell"><code>fmap :: (a -&gt; b) -&gt; ProgStateT a -&gt; ProgStateT b
fmap f (PST pst) =
  PST (\mem -&gt; let (x, mem&#39;) = pst mem
               in (f x, mem&#39;))</code></pre>
<p><code>fmap</code> basically says “Do the thing that the function says while staying within the Memory-state-managing context”.</p>
<p>Now we can say:</p>
<pre class="haskell"><code>evalStmt PrintMem = fmap printMemory getMemory
-- was: evalStmt PrintMem = PST (\mem -&gt; (printMemory mem, mem))</code></pre>
<p>This is a lot nicer to read once we get used to the pieces that brought it to life.</p>
<p>Now let’s consider the <code>Print</code> case. It’s a bit different, as it uses <code>evalExpr</code>:</p>
<pre class="haskell"><code>evalStmt (Print expr) =
  PST (\mem -&gt; let v = evalExpr expr mem
               in (putStrLn $ show v, mem))</code></pre>
<p>We can still use <code>fmap</code> however (the comments explain the types):</p>
<pre class="haskell"><code>evalStmt (Print expr) = fmap (print . evalExpr expr) getMemory
  -- print is putStrLn and show combined
  -- evalExpr expr :: Memory -&gt; Value
  -- print :: Value -&gt; IO ()
  -- print . evalExpr expr :: Memory -&gt; IO ()</code></pre>
<p>We tackle <code>Assign</code> next:</p>
<pre class="haskell"><code>evalStmt (Assign symbol expr) =
    PST (\mem -&gt; let v    = evalExpr expr mem
                     mem&#39; = store symbol v mem
                 in (return (), mem&#39;))</code></pre>
<p>Let’s think of the pieces of this function. The first is computing the value, the other is updating the memory. For this we might find the following function helpful. It simply applies the function to the memory to obtain a new memory.</p>
<pre class="haskell"><code>updateMemory :: (Memory -&gt; Memory) -&gt; ProgStateT ()
updateMemory f = PST (\mem -&gt; ((), f mem))</code></pre>
<p>In our case <code>store symbol v :: Memory -&gt; Memory</code> is such a function. Therefore we can consider <code>updateMemory (store symbol v)</code> as a <code>ProgStateT ()</code> value. Our main problem is that we need to compute the <code>v</code>, which depends on the memory as well.</p>
<p>– let e = Seq (Assign “x” (Add (Numb 2) (Numb 4))) $ Seq (Print $ Var “x”) $ PrintMem</p>
<p>With that in mind, our <code>evalStmt</code> function will gain the signature:</p>
<pre class="haskell"><code>evalStmt :: Stmt -&gt; State Memory (IO ())</code></pre>
<p>We will look at the details in a moment. But first, our <code>evaluate</code> becomes:</p>
<pre class="haskell"><code>evaluate :: Stmt -&gt; IO ()
evaluate stmt = evalState (evalStmt stmt) []
-- Before: evaluate stmt = io where (io, _) = evalStmt stmt []</code></pre>
<p>Now let’s consider the details of <code>evalStmt</code>. One of the cases we considered was:</p>
<pre class="haskell"><code>evalStmt PrintMem mem = (printMemory mem, mem)</code></pre>
<p>This would now become:</p>
<pre class="haskell"><code>evalStmt PrintMem = ST (\mem -&gt; (printMemory mem, mem))</code></pre>
<p>This weird-looking case is one important example of state-handling. In this case we do not need to <em>change</em> the state, only to <em>use</em> it. We could think of the above as a helper function:</p>
<pre class="haskell"><code>gets :: (s -&gt; a) -&gt; ST s a
gets f = ST (\mem -&gt; (f mem, mem))</code></pre>
<p>Then we can rewrite that part of <code>evalStmt</code> very simply as:</p>
<pre class="haskell"><code>evalStmt PrintMem = gets printMemory</code></pre>
<p>TODO: Rest needs rewrite! We can then model the program state via the <code>ST</code> type, using the <code>Memory</code> type as the state:</p>
<pre class="haskell"><code>type ProgState a = ST Memory a</code></pre>
<p>We can now write functions that turn expressions and statements into <code>ProgState</code> values: They all will carry the <code>Memory</code> with them and update as needed, while the type <code>a</code> will differ: statements will contain <code>IO ()</code> to indicate that they interact with the user (printing values when asked). Expressions will need to contain a <code>Value</code> type.</p>
<p>The advantage we get from this approach is that the task of updating and maintaining the state through every step is more or less hidden from our code, implemented in a single place in the <code>(&gt;&gt;=)</code> function.</p>
<pre class="haskell"><code>evalStmt :: Stmt  -&gt; ProgState (IO ())
evalStmt (Assign symbol expr) = do
    v &lt;- evalExpr expr   -- Evaluate expr, possibly state update
    modify (store symbol v)
    return $ return ()   -- Second return is the IO
evalStmt (Seq stmt1 stmt2) = do
    io1 &lt;- evalStmt stmt1
    io2 &lt;- evalStmt stmt2
    return $ io1 &gt;&gt; io2
evalStmt (Print expr) = do
    v &lt;- evalExpr expr
    return $ putStrLn $ show v
evalStmt PrintMem = do
    mem &lt;- getState
    return $ printMemory mem

printMemory :: Memory -&gt; IO ()
printMemory []            = return ()
printMemory ((s, v):rest) = do
    puStrLn $ s ++ &quot; = &quot; ++ show v
    printMemory rest

evaluate :: Stmt -&gt; IO ()
evaluate stmt = io
    where emptyMem = []
          program = evalStmt stmt
          (io, _) = runState program emptyMem</code></pre>
<h2 id="the-state-monad-1">The State Monad</h2>
<p>The idea of the State type is similar to our view of <code>IO</code> as a function that changed the “world” in some way and also produced a value of type <code>a</code>. The State type makes that more precise. It can work with very generic “states”, represented here with the type <code>s</code>. We can then make the following definition:</p>
<pre class="haskell"><code>newtype ST s a = S (s -&gt; (a, s))</code></pre>
<p>So a value of type <code>ST s a</code> is a <em>transition</em> function that takes the current state, and produces a value of type <code>a</code> along with a new (updated) state. For technical reasons we place that function inside an <code>S</code> tag. We can easily write a function that removes the tag:</p>
<pre class="haskell"><code>runState :: ST s a -&gt; s -&gt; (a, s)
runState (S trans) x = trans x
-- Could also have done: runState (S trans) = trans</code></pre>
<p>We can also write a function that evaluates a given stateful computation for a state, discards the resulting state and simply returns the final value:</p>
<pre class="haskell"><code>evalState :: ST s a -&gt; s -&gt; a
evalState (S trans) st = x&#39;
    where (x&#39;, _) = runState (S trans) st
-- Alternative definition: evalState state = fst . runState state</code></pre>
<p>In order to meaningfully work with this new state structure though, we will need a couple of things:</p>
<ul>
<li>A way to set the state to a new value. This is akin to <code>putStr</code> printing something to the screen and hence changing the state of IO.</li>
<li>A way to read the state, while going through a stateful computation.</li>
<li>A way to turn a normal value into a stateful computation. We did this for <code>IO</code> with a function called <code>return</code>, and we will do the same here.</li>
<li>A way to apply a normal function to the value in the computation, while keeping the state the same.</li>
<li>A way to chain two computations together, so that the state transfers from the first to the second. In Haskell that operation has a name, <code>(&gt;&gt;=)</code>, typically called a “bind” operation.</li>
</ul>
<p>Let us take a look at each of these. Getting and setting the state is easy:</p>
<pre class="haskell"><code>getState :: ST s s
getState = S (\st -&gt; (st, st))

putState :: s -&gt; ST s ()
putState st = S (\_ -&gt; ((), st))</code></pre>
<p>Now we need functions for returning a normal value as the result of a stateful computation that does not change the state, and also mapping the result values through a normal function:</p>
<pre class="haskell"><code>return :: a -&gt; ST s a
return x = S (\st -&gt; (x, st))

fmap :: (a -&gt; b) -&gt; ST s a -&gt; ST s b
fmap f (S trans) = S trans&#39;
    where trans&#39; st = (f x, st&#39;)
                      where (x, st&#39;) = trans st</code></pre>
<p>Now comes the tricky bit: We want to combine two stateful computations into a new stateful computation. Actually what we will do is slightly different: We will combine one stateful computation with a function that takes as input a result of the first computation, and uses it to produce a second stateful computation that is then carried out. It is probably the hardest part of the whole story:</p>
<pre class="haskell"><code>(&gt;&gt;=) :: ST s a -&gt; (a -&gt; ST s b) -&gt; ST s b
act1 &gt;&gt;= f = S trans
    where trans st = let (x, st&#39;) = runState act1 st
                         act2     = f x
                     in runState act2 st&#39;</code></pre>
<p>This all looks a bit messy, but we only had to do it and understand it once! Now we can use this chaining instead of having to effectively manually do it every time. The even cooler thing is that this effectively allows us to use the IO-type notation with <code>do</code>, and Haskell will unravel that for us. For example, we can build a function that modifies the current state, as follows:</p>
<pre class="haskell"><code>modify :: (s -&gt; s) -&gt; ST s ()
modify f = do
    st &lt;- getState
    putState (f st)</code></pre>
<p>And Haskell turns that into:</p>
<pre class="haskell"><code>modify f = getState &gt;&gt;= (\st -&gt; putState (f st))
-- Can also write as:   getState &gt;&gt;= (putState . f)</code></pre>
<p>which is perhaps elegant but somewhat harder to read, especially if it involved more steps. In order for Haskell to be able to carry this out, it must know that our <code>ST</code> structure is a “monad”. We will discuss what that means later in the chapter, but effectively it just means having the “bind” operation we just defined.</p>
<p><strong>Practice</strong>:</p>
<ol type="1">
<li>Using “do” notation, write a function <code>incr :: ST Int ()</code> that increments the integer state by 1. Also do it by instead using <code>modify</code>.</li>
<li>Using “do” notation, write a function <code>account :: a -&gt; ST Int a</code> which “accounts” for the computation that produces a value of type <code>a</code>, by incrementing the integer state. Your function should simply increment the state and return the provided value.</li>
</ol>
<script type="text/javascript">
let els = document.getElementsByTagName("pre");
for (const el of els) {
  const lang = el.getAttribute("class");
  if (lang != "") {
      el.children[0].setAttribute("class", "language-"+lang);
  }
}
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-java.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.15.0/components/prism-haskell.js"></script>
</body>
</html>
